import org.fusesource.jansi.AnsiConsole;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class Main {

    private static final int PORT = 1234;
    private static boolean end_client = false;
    private static String testing_attack = "";

    public static void delayedOutput(String output) {

        for (int k = 0; k < output.length(); k++) {
            try {
                Thread.sleep(3);

            } catch (InterruptedException ignored) {
            }
            System.out.print(output.charAt(k));
        }
        System.out.print("\n");

    }

    /**
     * Affiche le texte fourni avec un délai entre chaque caractère.
     *
     * @param output Le texte à afficher avec un délai entre chaque caractère.
     * @param delay  Le délai en millisecondes entre chaque caractère.
     */
    public static void delayedOutput(String output, int delay) {

        for (int k = 0; k < output.length(); k++) {

            try {
                Thread.sleep(delay);

            } catch (InterruptedException ignored) {
            }
            System.out.print(output.charAt(k));
        }
        System.out.print("\n");
    }

    /**
     * Point d'entrée principal de l'application.
     * Permet à l'utilisateur de choisir entre rejoindre une partie et héberger une partie.
     * La méthode gère les interactions utilisateur, la connexion à d'autres joueurs et le lancement d'un serveur de jeu.
     */
    public static void main(String[] args) {
        AnsiConsole.systemInstall();

        System.out.println("1. Rejoindre une partie");
        System.out.println("2. Héberger une partie");
        System.out.print("Choisissez une option : ");

        try (Scanner scanner = new Scanner(System.in)) {
            String optionString;
            int option = 0;

            while (true) {
                System.out.print("Entrez votre choix (1 ou 2) : ");
                optionString = scanner.nextLine().trim();

                if (optionString.equals("1") || optionString.equals("2")) {
                    option = Integer.parseInt(optionString);
                    break;
                } else {
                    System.out.println("Option invalide. Veuillez choisir 1 ou 2.");
                }
            }

            if (option == 1) {
                System.out.print("Entrez votre prénom : ");
                String playerName = scanner.nextLine();
                System.out.print("Entrez l'adresse IP de votre adversaire : ");
                String otherPlayerIP = scanner.nextLine();
                connectToOtherPlayer(playerName, otherPlayerIP);
            } else if (option == 2) {
                System.out.print("Entrez le nom de votre entreprise : ");
                String playerName = scanner.nextLine();
                delayedOutput("Vous devez \u001B[34mdéfendre\u001B[0m votre entreprise contre les \u001B[31mattaques\u001B[0m des" +
                        "\nméchants \u001B[33mh4ck3rs\u001B[0m. Vous avez un budget \u001B[33mlimité\u001B[0m qui augmente d'exactement " +
                        "\n3 $ toutes les 2 secondes. Mais \u001B[31mattention\u001B[0m, les \u001B[33mh4ck3rs\u001B[0m" +
                        "\npeuvent voler votre argent. Bonne chance !");
                simulateBlinkingCursor();
                simulateBlinkingCursor();
                startServer(playerName);
            }
        } catch (Exception e) {
            System.out.println("Une erreur s'est produite. Sortie.");
            e.printStackTrace();
        }
    }

    public static void Testing_attack() {
        System.out.println("Votre entreprise est touchée par u");

    }

    private static void check_attack() throws InterruptedException {
        if (!testing_attack.isEmpty()) {
            delayedOutput("\n\u001B[31m__________ATTAQUE EN COURS__________", 30);

        }
        switch (testing_attack) {

            case "":
                break;

            case "ransomware":
                delayedOutput("> Attaque: Ransomware", 40);
                simulateBlinkingCursor();
                delayedOutput("\n> Montant de la rançon: $10\u001B[0m", 40);
                simulateBlinkingCursor();
                DefenseManager.budget -= 10;
                delayedOutput("RANÇON PAYÉE.");
                if (DefenseManager.budget < 10) {
                    delayedOutput("Vous êtes désormais \u001B[31mendetté\u001B[0m. Vous devez attendre avant de rembourser la dette.");
                    delayedOutput("Veuillez patienter le temps que votre budget remonte...");
                    while (DefenseManager.budget < 0) {
                        Thread.sleep(3000);
                        System.out.println("Budget: " + DefenseManager.budget);
                    }
                }
                break;

            case "ddos":
                delayedOutput("> Attaque: DDOS", 40);
                simulateBlinkingCursor();
                delayedOutput("\n> Services H-S.\u001B[0m", 40);
                simulateBlinkingCursor();
                delayedOutput("\n> RETABLISSEMENT DES SERVICES...", 40);
                DefensiveSoftware.fakeProgressBar(100);
                System.out.println("\u001B[0m");
                break;

        }
        testing_attack = "";


    }

    /**
     * Établit une connexion avec un autre joueur en utilisant une adresse IP donnée.
     * Permet d'envoyer différentes attaques à l'autre joueur via un socket.
     *
     * @param playerName    Le nom du joueur actuel.
     * @param otherPlayerIP L'adresse IP de l'autre joueur.
     */
    private static void connectToOtherPlayer(String playerName, String otherPlayerIP) {
        try (Socket socket = new Socket(otherPlayerIP, PORT)){
            System.out.println("Connected to the other player.");

            new Thread(() -> handleIncomingMessages(socket)).start();
            boolean done = false;
            String attaque = "";
            while (!done) {
                System.out.println("Lancez une attaque parmis les suivantes:");
                System.out.println("[1] - Ransomware\n[2] - DDOS\n[3] - Reconaissance\n");

                // Attend l'entrée de l'utilisateur pour choisir une attaque
                attaque = new Scanner(System.in).nextLine();
                ExploitFramework ef = new ExploitFramework();

                switch (attaque) {

                    case "1":
                        attaque = "ransom";
                        break;

                    case "2":
                        attaque = "ddos";

                        break;

                    case "3":
                        attaque = "reco";

                        break;

                    default:
                        break;

                }
                // Envoie l'attaque via le socket
                try (PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) {
                    writer.println(attaque);
                }
            }
            isRunning = false;
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Simule un curseur clignotant pour afficher visuellement une opération en cours.
     * Le curseur alterne entre être visible et invisible à des intervalles réguliers.
     */
    public static void simulateBlinkingCursor() {
        boolean cursorVisible = true;

        for (int i = 0; i < 6; i++) {
            System.out.print("\r");

            if (cursorVisible) {
                System.out.print("█"); // Caractère représentant le curseur visible
            } else {
                System.out.print(" "); // Caractère représentant le curseur invisible
            }

            cursorVisible = !cursorVisible;

            try {
                // Pause pour créer l'effet de clignotement
                Thread.sleep(150);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * Initialise un serveur pour le joueur Entreprise, permettant la connexion d'un adversaire.
     * Gère l'installation et la gestion des défenses par le joueur.
     *
     * @param playerName Le nom de l'entreprise fictive du joueur qui démarre le serveur.
     */
    private static void startServer(String playerName) throws IOException {
        try(ServerSocket serverSocket = new ServerSocket(PORT))  {

            System.out.println("En attente d'adversaire...");
            System.out.println("Votre adresse IP est: " + getLocalIpAddress());

            Socket socket = serverSocket.accept();
            System.out.println("Connexion effectuée.");
            DefenseManager defman = new DefenseManager();
            new Thread(() -> handleIncomingMessages(socket)).start();

            boolean done = false;
            while (!done) {
                check_attack();

                delayedOutput(defman.print_info(), 1);
                simulateBlinkingCursor();
                delayedOutput("Installez une défense parmis les suivantes:");
                delayedOutput("\u001B[34mAntivirus__________\u001B[0m");
                delayedOutput("[1] - Ariva economy \u001B[36m$" + new AntivirusLevel1().getPrice() + "\u001B[0m " + defman.printIsInstalled(new AntivirusLevel1()));
                delayedOutput("[2] - AI Protect Pro \u001B[36m$" + new AntivirusLevel2().getPrice() + "\u001B[0m " + defman.printIsInstalled(new AntivirusLevel2()));
                delayedOutput("[3] - CyberSecure MegaDefender 9000 Ultra Turbo Extreme Edition \u001B[36m$" + new AntivirusLevel3().getPrice() + "\u001B[0m" + defman.printIsInstalled(new AntivirusLevel3()) + " \n");

                delayedOutput("\u001B[33mFirewall__________\u001B[0m");
                delayedOutput("[4] - Bicrosoft Firewall \u001B[36m$" + new FirewallLevel1().getPrice() + "\u001B[0m " + defman.printIsInstalled(new FirewallLevel1()));
                delayedOutput("[5] - FenceGuard lite \u001B[36m$" + new FirewallLevel2().getPrice() + "\u001B[0m " + defman.printIsInstalled(new FirewallLevel2()));
                delayedOutput("[6] - FortressPro Elite Security Suite \u001B[36m$" + new FirewallLevel3().getPrice() + "\u001B[0m " + defman.printIsInstalled(new FirewallLevel3()) + " \n");

                delayedOutput("\u001B[35mChiffrement__________\u001B[0m");
                delayedOutput("[7] - SecureLite Encryptor \u001B[36m$" + new ChiffrementLevel1().getPrice() + "\u001B[0m " + defman.printIsInstalled(new ChiffrementLevel1()));
                delayedOutput("[8] - CipherGuard 360 Standard Edition \u001B[36m$" + new ChiffrementLevel2().getPrice() + "\u001B[0m " + defman.printIsInstalled(new ChiffrementLevel2()));
                delayedOutput("[9] - QuantumShield Pro Cryptographic Suite, Maximum Edition \u001B[36m$" + new ChiffrementLevel3().getPrice() + "\u001B[0m " + defman.printIsInstalled(new ChiffrementLevel3()) + " \n");

                delayedOutput("\u001B[32mFurtivité__________\u001B[0m");
                delayedOutput("[10] - SudVPN \u001B[36m$" + new ObfuscLevel1().getPrice() + "\u001B[0m " + defman.printIsInstalled(new ObfuscLevel1()));
                delayedOutput("[11] - CipherGuard 360 Standard Edition \u001B[36m$" + new ObfuscLevel2().getPrice() + "\u001B[0m " + defman.printIsInstalled(new ObfuscLevel2()));
                delayedOutput("[12] - QuantumCloak Pro Stealth Enhancer Supreme Ultra Mega Cybernetic Guardian \u001B[36m$" + new ObfuscLevel3().getPrice() + "\u001B[0m " + defman.printIsInstalled(new ObfuscLevel3()) + " \n");

                simulateBlinkingCursor();
                check_attack();

                System.out.print("\nadmin@" + playerName + ":~#");

                String software = new Scanner(System.in).nextLine();
                check_attack();

                switch (software) {

                    case "1":
                        defman.installSoftware(new AntivirusLevel1());
                        break;

                    case "2":
                        defman.installSoftware(new AntivirusLevel2());
                        break;

                    case "3":
                        defman.installSoftware(new AntivirusLevel3());
                        break;

                    case "4":
                        defman.installSoftware(new FirewallLevel1());
                        break;

                    case "5":
                        defman.installSoftware(new FirewallLevel2());
                        break;

                    case "6":
                        defman.installSoftware(new FirewallLevel3());
                        break;

                    case "7":
                        defman.installSoftware(new ChiffrementLevel1());
                        break;

                    case "8":
                        defman.installSoftware(new ChiffrementLevel2());
                        break;

                    case "9":
                        defman.installSoftware(new ChiffrementLevel3());
                        break;

                    case "10":
                        defman.installSoftware(new ObfuscLevel1());
                        break;

                    case "11":
                        defman.installSoftware(new ObfuscLevel2());
                        break;

                    case "12":
                        defman.installSoftware(new ObfuscLevel3());
                        break;

                    case "13":
                        done = true;
                        break;

                    default:
                        System.out.println("option invalide.");
                        break;
                }
            }

            System.out.println(defman.getInstalledSoftware());
            defman.getScores();

        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }


    /**
     * Obtient l'adresse IP locale de l'appareil en établissant une connexion avec un serveur distant.
     *
     * @return L'adresse IP locale de l'appareil ou "N/A" en cas d'erreur.
     */
    private static String getLocalIpAddress() {
        try (Socket socket = new Socket("google.com", 80)) {
            // Retourne l'adresse IP locale de l'appareil
            return socket.getLocalAddress().getHostAddress();
        } catch (IOException e) {
            // En cas d'erreur, imprime la trace de la pile et retourne "N/A"
            e.printStackTrace();
            return "N/A";
        }
    }




    private static volatile boolean isRunning = true;


    /**
     * Gère les messages entrants provenant d'une connexion de socket.
     * La fonction lit les messages provenant du flux d'entrée du socket et réagit en conséquence.
     *
     * @param socket Le socket à partir duquel les messages sont reçus.
     */
    private static void handleIncomingMessages(Socket socket) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
            while (isRunning) {
                String line = reader.readLine();
                if (line == null) {
                    // La fin du flux a été atteinte, le socket a été fermé par l'autre extrémité.
                    break;
                }

                if (line.equals("ransom")) {
                    testing_attack = "ransomware";
                } else if (line.equals("ddos")) {
                    testing_attack = "ddos";
                }            }
        } catch (IOException e) {
            // Gérez les exceptions (par exemple, imprimez-les ou effectuez d'autres actions)
        }
    }


}